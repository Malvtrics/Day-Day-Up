1:全Javascript的架构是否适合于产品级的应用呢？
  不得不承认，如果开发堆栈的每一层都能使用JavaScript将会是一件很棒的事情（至少对于原型开发来说是这样），
  然而千万要注意，不要为了追求这一目标，而把自己而束缚住了。
  尽管的确有越来越多的大规模应用都在采用类似的架构，如Walmart、LinkedIn，但并不意味着模仿他们就一定能成功。
  另一个需要注意的是，相对于其他的语言（如Ruby，Python或Java），
  在Node上搭建后端要困难得多。你可能要自己处理内存泄漏，避免在事件循环中进行耗时运算，还要非常小心异常处理，
  如果这些处理不当就很有可能会导致整个应用服务器崩溃，但是这些问题在其他平台上却已经处理得很好了
  。然而，这并不是说，Node不能运用在生产环境下，当然可以，但要格外用心。
  实话实说，想要“一揽子”为Web应用提供一个大而全的解决方案将非常困难，
  MEAN架构也肯定有其局限性。在前端与后端的设计模式、原则和风格中有大量的演化，
  如果你觉得PHP或Rails是更明智的选择，那就继续使用下去，否则的话，不妨试试MEAN，至少在当下值得一试。
2:random 产生随即数不能保证唯一性,唯一性一般要和时间结合起来, 可以参考star的shortid的源码
3: Jquery is designed to do 4 things:
  1) traversing DOM
  2) animation
  3) event handling 
  4) ajax interaction
4: Babel is a JavaScript compiler.Babel kneden -> make async to promise  
  surf "https://github.com/marten-de-vries/kneden" for more details
5: FirstLine
  \SecondLine\
   ThirdLine
   var myStr = "FirstLine\n\\SecondLine\\\rThirdLine";
   1: in js,string is immutable , (array is immutable , can be changed with index )
2: Variables which are used without the var keyword are automatically created in the global scope.
3: 1 == '1' true(equal) 
   1 === '1' false(strict equal)(data type)
   Like the equality operator, less than operator converts data types while comparing.'1' < 2(true)
4: switch case use strict equality
5: http://json.org/ (json explanation)
6: js function return everything no definition for return type when declare;
7: {"name":"marten"} hasOwnProperty("name")
   {name: "marten"}  hasOwnProperty(name)
8: Math.floor(Math.random() * (max - min + 1)) + min
9: javascript getMonth 0-11 need to + 1 in some cases
10: Regular expressions => /the/gi
   / is the start of the regular expression.
   the is the pattern we want to match.
   / is the end of the regular expression.
   g means global, which causes the pattern to return all matches in the string, not just the first one.
   i means that we want to ignore the case (uppercase or lowercase) when searching for the pattern.
11:/\d+/g (\d) in js replace function replace(/\d+/gi)  not replace('/\d+/'), it is not a string 
   /\s+/ (\s) contrary(\S)
   whitespace including: " " (space), \r (the carriage return), \n (newline), \t (tab), and \f (the form feed).
12: in an object , using this-> public , using var-> private
13: js array methods: map/reduce/filter/sort
    reminder: to filter function -> callback returns true will be kept.
    sort function: sort can be passed a compare function as a callback. The compare function should return
         a negative number if a should be before b, a positive number if a should be after b,  or 0 if they are equal.
14:The second argument to substring is the index to stop at (but not include),    
   but the second argument to substr is the maximum length to return.
15:slice/splice usage need to be enhanced
16: \ in string is meaningless, should use \\ instead
17: indexOf can be used for string and array
18: charCodeAt()  fromCharCode() very useful
19: Object.keys(val) good method for parsing json data
20: pre-filter json data:
    json = json.filter(function(val) {
      return (val.id !== 1);
    });
21: get user's position 
 if (navigator.geolocation) {
   navigator.geolocation.getCurrentPosition(function(position) {
     $("#data").html("latitude: " + position.coords.latitude + "<br>longitude: " + position.coords.longitude);
   });
 }
22: for same origin policy: https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy
    http/https 2 prototals , can't use ajax with one kind through another
23: for cross origin-request: use jsonp
24: $("[name='query']") use this kind of selector
25: difference between em and rem and px
26: only 4 kb => nodelist.js => can replace jquery under most conditions => https://github.com/eorroe/NodeList.js/tree/master
27: The differences between Js's window.onload and Jquery's $(document).ready?
  The ready event occurs after the HTML document has been loaded , while the onload event occurs later , when all content 
  (eg. images) also has been loaded.
  The onload evenet is a standard event in the Dom , while the ready evenet is specific to jQuery , the purpose of the ready event 
  is that it should occur as early as possible after the document has loaded , so that code that adds functionality to the elements 
  in the page doesn.t have to wait for all content to load.
28:Jquery
  content ops: html()/text()
  class ops: addClass()/css()
  append content: append()/appendTo()/before()/after()
  copy: clone()
  replace elements: replaceWith()/replaceAll()
  wrap elements: wrap()/wrapInner()
  delete elements: remove()/empty()
  binding events: bind()/unbind()
  toggle(speed,callback) (for hide and show)
  slideToggle([duration],[,complete]) description: display or hide the matched elements with a sliding motion
  one time event: one(event,[data],function)
  trigger the events: trigger(event)
  basic animation effects (fade/slide)
  custom animation effects animate({params},speed , callback)
  stop animation: stop()
  get data from server: load(url , data, callback)/getJson(url,[data],callback)/getScript(url,[callback])/get(url,callback)
  send data to server: post(url,data,callback)
29: javascript 内存管理
  详细: https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Memory_Management
  概要:
  1)引用计数垃圾收集
      理念:“对象有没有其他对象引用到它”。如果没有引用指向该对象（零引用），对象将被垃圾回收机制回收。
  限制：循环引用
      这个简单的算法有一个限制，就是如果一个对象引用另一个（形成了循环引用），他们可能“不再需要”了，但是他们不会被回收。
  2)标记-清除算法 
      理念:假定设置一个叫做根的对象（在Javascript里，根是全局对象）。定期的，垃圾回收器将从根开始，找所有从根开始引用的对象，
      然后找这些对象引用的对象……从根开始，垃圾回收器将找到所有可以获得的对象和所有不能获得的对象。
  从2012年起，所有现代浏览器都使用了标记-清除垃圾回收算法。所有对JavaScript垃圾回收算法的改进都是基于标记-清除算法的改进
  限制: 那些无法从根对象查询到的对象都将被清除
30 new vs prototype 
http://thecodeship.com/web-development/methods-within-constructor-vs-prototype-in-javascript/
31 一套经典的闭包题目
function fun(n,o) {
  console.log(o)
  return {
    fun:function(m){
      return fun(m,n);
    }
  };
}
var a = fun(0);  a.fun(1);  a.fun(2);  a.fun(3);//undefined,?,?,?
var b = fun(0).fun(1).fun(2).fun(3);//undefined,?,?,?
var c = fun(0).fun(1);  c.fun(2);  c.fun(3);//undefined,?,?,?
//问:三行a,b,c的输出分别是什么？
http://www.cnblogs.com/xxcanghai/p/4991870.html
32: addEventListener 最后一个参数为true表明用捕获方式
对于点击的target　事件执行顺序取决于绑定的顺序
