概念1： 多项式时间 

时间复杂度并不是表示一个程序解决问题需要花多少时间，而是当问题规模扩大后，程序需要的时间长度增长得有多快。
也就是说，对于高速处理数据的计算机来说，处理某一个特定数据的效率不能衡量一个程序的好坏，
而应该看当这个数据的规模变大到数百倍后，程序运行时间是否还是一样，或者也跟着慢了数百倍，或者变慢了数万倍。

不管数据有多大，程序处理花的时间始终是那么多的，我们就说这个程序很好，具有O(1)的时间复杂度，也称常数级复杂度；
数据规模变得有多大，花的时间也跟着变得有多长，这个程序的时间复杂度就是O(n)，
比如找n个数中的最大值；而像冒泡排序、插入排序等，数据扩大2倍，时间变慢4倍的，属于O(n^2)的复杂度。
还有一些穷举类的算法，所需时间长度成几何阶数上涨，这就是O(a^n)的指数级复杂度，甚至O(n!)的阶乘级复杂度。

前面的几类复杂度被分为两种级别，一种是O(1),O(log(n)),O(n^a)等，我们把它叫做多项式级的复杂度，因为它的规模n出现在底数的位置；
另一种是O(a^n)和O(n!)型复杂度，它是非多项式级的，其复杂度计算机往往不能承受。
当我们在解决一个问题时，我们选择的算法通常都需要是多项式级的复杂度，非多项式级的复杂度需要的时间太多，往往会超时，除非是数据规模非常小。

概念2： P问题和NP问题

P就是能在多项式时间内解决的问题，NP就是能在多项式时间验证答案正确与否的问题。用大白话讲大概就是这样。
所以P是否等于NP实质上就是在问，如果对于一个问题我能在多项式时间内验证其答案的正确性，那么我是否能在多项式时间内解决它？
这个表述不太严谨，但通俗来讲就是如此。

概念3: global clock 全局时钟

在分布式系统里，每个系统都有自己的时钟，即便用 NTP（Network Time Protocol）同步，大家也无法严格步调一致
要解决因为时钟不同，步调不一致而导致的 out of sync 的问题，我们需要设法形成一个逻辑上的「时钟」，让大家都认可这个「时钟」而不是自己的时钟
这个逻辑时钟的第一个实现是 Lamport timestamps（请记住 Lamport 这位图灵奖获得者，分布式系统的先驱，下文他还会上镜）。
Lamport timestamps 学术价值大于实际价值，并没有系统实际使用，然而在它之上演进出的 vector clock 广泛被 AWS S3，DynamoDB，Riak 等系统采用，
用于确保同一个 object 的因果关系
details: https://zhuanlan.zhihu.com/p/34195307

概念4：分布式计算和并行计算的区别

并行计算中不同单元之间的通信延迟和成本很低
分布式计算中，一般认为通讯的延迟和/或成本很高。一种常用的抽象是假设节点内部的计算没有成本，算法的复杂度用节点之间的通讯量来衡量

衍生内容：并行计算 PC-》分布式计算 DC-》多方计算 MPC multiparty computation
在现实中，因为延迟的关系。通讯轮数经常比通讯量更重要。所以 MPC中，一个关注的要点（也是一个 open problem）就是如何最小化通讯轮数。

概念5：图论中如何定义两顶点之间的距离？直径？半径？

一张无向图里，两顶点之间的距离是指他们之间最短路径的长度，两顶点之间的距离也被称为测地距离。
需要注意的是两个顶点之间可能有多条最短路径，如果两个顶点之间不存在路径，那么按照传统它们距离被定义为无穷大。 

在有向图中，如果从顶点到顶点存在有向路径，那么距离被定义为从顶点到顶点之间最短有向路径的长度

直径：上述距离中的最大值，图中距离最远的两个点
半径：有点瞌睡，理解不了了。。。

概念6：图的BFS和DFS
简单介绍：
BFS 找点入队 出队为黑 入队为灰 队外为白
DFS 设定初始点 一路找到黑 回溯
https://www.jianshu.com/p/70952b51f0c8










